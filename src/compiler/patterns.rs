use regex::Regex;

pub struct Patterns {
    // single chars
    pub l_paren: Regex,
    pub r_paren: Regex,
    pub l_brace: Regex,
    pub r_brace: Regex,
    pub comma: Regex,
    pub dot: Regex,
    pub minus: Regex,
    pub plus: Regex,
    pub semi: Regex,
    pub slash: Regex,
    pub star: Regex,
    // one or two chars
    pub bang: Regex,
    pub bang_eq: Regex,
    pub eq: Regex,
    pub eq_eq: Regex,
    pub gt: Regex,
    pub gt_eq: Regex,
    pub lt: Regex,
    pub lt_eq: Regex,
    // literals
    pub identifier: Regex,
    pub str: Regex,
    pub num: Regex,
    // keywords
    pub and: Regex,
    pub or: Regex,
    pub class: Regex,
    pub else_: Regex,
    pub if_: Regex,
    pub fn_: Regex,
    pub for_: Regex,
    pub while_: Regex,
    pub nil: Regex,
    pub print: Regex,
    pub return_: Regex,
    pub this: Regex,
    pub true_: Regex,
    pub false_: Regex,
    pub interface: Regex,
    pub word_pattern: Regex,
    pub any: Regex,
}

impl Patterns {
    pub fn new() -> Self {
        Self {
            l_paren: Regex::new(r"^\(").unwrap(),
            r_paren: Regex::new(r"^\)").unwrap(),
            l_brace: Regex::new(r"^\{").unwrap(),
            r_brace: Regex::new(r"^\}").unwrap(),
            comma: Regex::new(r"^,").unwrap(),
            num: Regex::new(r"^-?([0-9]+|[0-9]+\.[0-9]+)").unwrap(),
            dot: Regex::new(r"^\.").unwrap(),
            minus: Regex::new(r"^-").unwrap(),
            plus: Regex::new(r"^\+").unwrap(),
            semi: Regex::new(r"^;").unwrap(),
            slash: Regex::new(r"^\/").unwrap(),
            star: Regex::new(r"^\*").unwrap(),
            bang: Regex::new(r"^!").unwrap(),
            bang_eq: Regex::new(r"^!=").unwrap(),
            eq: Regex::new(r"^=").unwrap(),
            eq_eq: Regex::new(r"^==").unwrap(),
            gt: Regex::new(r"^>").unwrap(),
            gt_eq: Regex::new(r"^>=").unwrap(),
            lt: Regex::new(r"^<").unwrap(),
            lt_eq: Regex::new(r"^<=").unwrap(),
            str: Regex::new(r#"".*""#).unwrap(),
            and: Regex::new(r"^and").unwrap(),
            or: Regex::new(r"^or").unwrap(),
            class: Regex::new(r"^class").unwrap(),
            else_: Regex::new(r"^else").unwrap(),
            if_: Regex::new(r"^if").unwrap(),
            fn_: Regex::new(r"^fn").unwrap(),
            for_: Regex::new(r"^for").unwrap(),
            while_: Regex::new(r"^while").unwrap(),
            nil: Regex::new(r"^nil").unwrap(),
            print: Regex::new(r"^print").unwrap(),
            return_: Regex::new(r"^return").unwrap(),
            this: Regex::new(r"^this").unwrap(),
            true_: Regex::new(r"^true").unwrap(),
            false_: Regex::new(r"^false").unwrap(),
            interface: Regex::new(r"^interface").unwrap(),
            identifier: Regex::new(r"^[a-zA-z_][a-zA-z_0-9]*").unwrap(),
            word_pattern: Regex::new(r"\w").unwrap(),
            any: Regex::new(r#"(\(|\)|\{|\}|,|-?([0-9]+\.[0-9]+|[0-9]+)|\.|-|\+|;|\/|\*|!=|!|==|=|>=|>|<=|<|".*"|[a-zA-z_][a-zA-z_0-9]*|\S+)"#).unwrap(),
        }
    }
}
